package deltix.kafka.connect;

import deltix.qsrv.hf.pub.RawDecoder;
import deltix.qsrv.hf.pub.RawMessage;
import deltix.qsrv.hf.pub.codec.InterpretingCodecMetaFactory;
import deltix.qsrv.hf.pub.codec.NonStaticFieldInfo;
import deltix.qsrv.hf.pub.codec.UnboundDecoder;
import deltix.qsrv.hf.pub.md.*;
import deltix.util.memory.MemoryDataInput;
import org.apache.kafka.connect.data.*;
import org.apache.kafka.connect.errors.DataException;
import org.apache.kafka.connect.source.SourceRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;

import static deltix.kafka.connect.LogicalType.TIMESTAMP_MS;
import static deltix.kafka.connect.LogicalType.TIME_MS;
import static deltix.kafka.connect.TBSourceTask.OFFSET_ATTR;
import static deltix.kafka.connect.TBSourceTask.TIMESTAMP_ATTR;

public class RawMessageDeserializer {
    private final static Logger LOG = LoggerFactory.getLogger(RawMessageDeserializer.class);

    private final RecordClassDescriptor msgType;
    private final Map<String, Schema> schemaRegistry = new HashMap<>();
    private final Map<String, UnboundDecoder> decoders = new HashMap<>();
    private final MemoryDataInput input = new MemoryDataInput ();
    private final RawDecoder rawDecoder = new RawDecoder();
    private final DateFormat iso8601Format;
    private final DateFormat timeOfDayFormat;

    private String instrumentField;
    private String symbolField;
    private String timeField;
    private FieldSelection fieldSelection;
    private FieldMap fieldMap;
    private List<String> keyFields;
    private String tbMessageId;
    private String topic;

    public RawMessageDeserializer(RecordClassDescriptor msgType, TBConnectorConfig config) {
        this.msgType = msgType;
        this.instrumentField = config.getInstrumentField();
        this.symbolField = config.getSymbolField();
        this.timeField = config.getTimeField();
        this.fieldSelection = config.getFieldSelection();
        this.fieldMap = config.getNameAliases();
        this.keyFields = config.getKeyFields();
        this.tbMessageId = config.getTBMessageIDField();
        this.topic = config.getTopic();

        this.iso8601Format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
        this.iso8601Format.setTimeZone(TimeZone.getTimeZone("UTC"));
        this.timeOfDayFormat = new SimpleDateFormat("HH:mm:ss.SSS");
        this.timeOfDayFormat.setTimeZone(TimeZone.getTimeZone("UTC"));

        getSchema(msgType); // build schema now
    }

    private void validateDescriptor(RecordClassDescriptor msgType) {
        if (instrumentField != null && msgType.hasField(instrumentField))
            throw new IllegalArgumentException("Field \"" + instrumentField + "\" already exists in TimeBase message");
        if (symbolField != null && msgType.hasField(symbolField))
            throw new IllegalArgumentException("Field \"" + symbolField + "\" already exists in TimeBase message");
        if (timeField != null && msgType.hasField(timeField))
            throw new IllegalArgumentException("Field \"" + timeField + "\" already exists in TimeBase message");

        for (String fieldName : fieldMap.getSourceFields()) {
            if (!msgType.hasField(fieldName)) {
                throw new IllegalArgumentException("TimeBase message does not contain renamed field \"" + fieldName + "\"");
            }
        }

        if (keyFields != null) {
            for (String fieldName : keyFields) {
                if (!msgType.hasField(fieldName))
                    throw new IllegalArgumentException("TimeBase message does not contain key field \"" + fieldName + "\"");
            }
        }
    }

    private Schema buildSchema(RecordClassDescriptor msgType) {
        boolean debug = LOG.isDebugEnabled();
        validateDescriptor(msgType);

        final SchemaBuilder schemaBuilder = SchemaBuilder.struct();
        schemaBuilder.name(msgType.getName());
        schemaBuilder.doc("Generated by TBSourceConnector from " + msgType.getName());

        // add "header" fields
        if (instrumentField != null)
            schemaBuilder.field(instrumentField, Schema.OPTIONAL_STRING_SCHEMA);
        if (symbolField != null)
            schemaBuilder.field(symbolField, Schema.OPTIONAL_STRING_SCHEMA);
        if (timeField != null)
            schemaBuilder.field(timeField, TIMESTAMP_MS.getSchema());

        for (DataField field : msgType.getFields()) {
            if (fieldSelection != null && !fieldSelection.isSelected(field.getName())) {
                if (debug)
                    LOG.debug("Skipping excluded field: " + field.getName());
                continue; // skip excluded field
            }

            //if (field instanceof StaticDataField) {
                //Object fieldValue = ((StaticDataField) field).getBoxedStaticValue();
                //TODO use it as default
            //}
            String fieldName = fieldMap.getDestination(field.getName());
            Schema fieldSchema = getFieldSchema(field.getType());
            schemaBuilder.field(fieldName, fieldSchema);
            LOG.info("Added Field: " + fieldName + "/" + fieldSchema.name() + "/" + fieldSchema.type() + (fieldSchema.isOptional() ? " (Optional)": ""));
        }

        return schemaBuilder.build();
    }

    private UnboundDecoder getDecoder (final RecordClassDescriptor type) {
        String guid = type.getGuid();
        UnboundDecoder decoder = decoders.get(guid);
        if (decoder == null) {
            decoder = InterpretingCodecMetaFactory.INSTANCE.createFixedUnboundDecoderFactory (type).create ();
            decoders.put (guid, decoder);
        }
        return decoder;
    }

    public Struct deserialize(RawMessage message) {
        Map<String, Object> values = getValues(message);
        return buildStruct(null, getSchema(message.type), values);
    }

    public SourceRecord deserialize(RawMessage message, Map<String,String> partition, long messageTimestamp, long messageCounter) {
        Map<String, Object> values = getValues(message);
        Struct value = buildStruct(null, getSchema(message.type), values);

        long msgOffset = (tbMessageId == null) ? messageCounter : (Long) values.get(tbMessageId);
        HashMap<String, Long> offset = new HashMap<>(2);
        offset.put(TIMESTAMP_ATTR, messageTimestamp);
        offset.put(OFFSET_ATTR, msgOffset);

        String key = buildKey(values, messageTimestamp, msgOffset);

        return new SourceRecord(partition, offset, topic, Schema.STRING_SCHEMA, key, value.schema(), value);
    }

    private String buildKey(Map<String, Object> values, long timestamp, long offset) {
        StringBuilder keyBuilder = new StringBuilder();

        if (keyFields == null || keyFields.size() == 0) {
            keyBuilder.append(timestamp).append(TBConnectorConfig.KEY_FIELDS_SEPARATOR).append(offset);
        }
        else {
            for (String fieldName : keyFields) {
                if (keyBuilder.length() > 0)
                    keyBuilder.append(TBConnectorConfig.KEY_FIELDS_SEPARATOR);

                Object fieldValue = values.get(fieldName);
                if (fieldValue != null) {
                    DataField field = msgType.getField(fieldName);
                    DataType fieldType = field.getType();
                    if (fieldType instanceof DateTimeDataType) {
                        keyBuilder.append(iso8601Format.format(new Date((Long) fieldValue)));
                    }
                    else if (fieldType instanceof TimeOfDayDataType) {
                        keyBuilder.append(timeOfDayFormat.format(new Date(((Integer) fieldValue).longValue())));
                    }
                    else {
                        keyBuilder.append(fieldValue);
                    }
                }
            }
        }
        return keyBuilder.toString();
    }

    protected Schema getSchema(RecordClassDescriptor msgType) {
        final String guid = msgType.getGuid();
        Schema valueSchema = schemaRegistry.get(guid);
        if (valueSchema == null) {
            valueSchema = buildSchema(msgType);
            schemaRegistry.put(guid, valueSchema);
            LOG.info("Built Schema for " + msgType.getName() + ": " + valueSchema);
        }
        return valueSchema;
    }

    private Struct buildStruct(Schema parentSchema, Schema schema, Map<String, Object> values) {
        Struct struct = new Struct(schema);

        List<Field> fields = schema.fields();
        for (org.apache.kafka.connect.data.Field field : fields) {
            String fieldName = field.name();
            // renaming is supported for the top level fields only
            if (parentSchema == null) {
                fieldName = fieldMap.getSource(field.name());
            }
            Object fieldValue = values.get(fieldName);
            if (fieldValue != null) {
                switch (field.schema().type()) {
                    case STRUCT:
                        fieldValue = buildStruct(schema, field.schema(), (Map<String, Object>) fieldValue);
                        break;
                    case ARRAY:
                        Object[] arrayValue = (Object[]) fieldValue;
                        fieldValue = Arrays.asList(arrayValue);
                        break;
                    case STRING:
                        // convert to String in case the value is Character or CharSequence
                        fieldValue = fieldValue.toString();
                        break;
                    case INT64:
                        if (TIMESTAMP_MS.getLogicalName().equals(field.schema().name()))
                            fieldValue = Timestamp.toLogical(field.schema(), (Long) fieldValue);
                        break;
                    case INT32:
                        if (TIME_MS.getLogicalName().equals(field.schema().name()))
                            fieldValue = Time.toLogical(field.schema(), (Integer) fieldValue);
                        break;

                    default:
                        // do nothing
                }

                struct.put(field.name(), fieldValue);

            } else {
                if (! field.schema().isOptional()) {
                    throw new DataException(String.format("Field '%s' is required but no value was set.", field.name()));
                }
            }
        }
        return struct;
    }

    public Map<String, Object> getValues(RawMessage msg) {
        final HashMap<String, Object> values = new HashMap<>();
        if (instrumentField != null && msg.getInstrumentType() != null)
            values.put(instrumentField, msg.getInstrumentType().name());
        if (symbolField != null && msg.getSymbol() != null)
            values.put(symbolField, msg.getSymbol().toString());
        if (timeField != null)
            values.put(timeField, msg.getTimeStampMs());

        if (msg.data != null) {
            final UnboundDecoder decoder = getDecoder(msg.type);
            input.setBytes(msg.data, msg.offset, msg.length);

            decoder.beginRead(input);
            while (decoder.nextField()) {
                final NonStaticFieldInfo field = decoder.getField();
                Object value = rawDecoder.readField(field.getType(), decoder);
                values.put(field.getName(), value);
            }
        }
        return values;
    }

    public Schema getFieldSchema(DataType type) {
        if (type.isPrimitive()) {
            return getPrimitiveTypeSchema(type);

        } else if (type instanceof ArrayDataType) {
            return getArraySchema((ArrayDataType) type);

        } else if (type instanceof ClassDataType) {
            return getObjectSchema((ClassDataType) type);

        } else {
            throw new IllegalArgumentException("Unrecognized dataType: " + type);
        }
    }

    private Schema getPrimitiveTypeSchema(DataType type) {
        assert type.isPrimitive() : "Not primitive type";

        Schema.Type schemaType;
        Object defaultValue = null;
        LogicalType logicalType = null;

        if (type instanceof IntegerDataType) {
            int size = ((IntegerDataType) type).getNativeTypeSize();
            if (size >= 6) {
                schemaType = Schema.Type.INT64;
                //defaultValue = 0L;
            } else if (size == 1) {
                schemaType = Schema.Type.INT8;
                //defaultValue = (byte) 0;
            } else if (size == 2) {
                schemaType = Schema.Type.INT16;
                //defaultValue = (short) 0;
            } else {
                schemaType = Schema.Type.INT32;
                //defaultValue = 0;
            }
        } else if (type instanceof FloatDataType) {
            if (((FloatDataType) type).isFloat()) {
                schemaType = Schema.Type.FLOAT32;
                //defaultValue = 0.0F;
            } else {
                schemaType = Schema.Type.FLOAT64;
                //defaultValue = 0.0D;
            }
        } else if (type instanceof CharDataType ||
                type instanceof EnumDataType ||
                type instanceof VarcharDataType) {
            schemaType = Schema.Type.STRING;
        } else if (type instanceof BooleanDataType) {
            schemaType = Schema.Type.BOOLEAN;
            //defaultValue = false;
        } else if (type instanceof DateTimeDataType) {
            schemaType = Schema.Type.INT64;
            logicalType = TIMESTAMP_MS;
            //defaultValue = 0L;
        } else if (type instanceof TimeOfDayDataType) {
            schemaType = Schema.Type.INT32;
            logicalType = TIME_MS;
            //defaultValue = 0;
        } else if (type instanceof BinaryDataType) {
            schemaType = Schema.Type.BYTES;
        } else {
            throw new RuntimeException("Unrecognized dataType: " + type);
        }

        SchemaBuilder schemaBuilder = SchemaBuilder.type(schemaType);
        if (type.isNullable()) {
            schemaBuilder.optional().defaultValue(defaultValue);
        }

        if (logicalType != null) {
            schemaBuilder.name(logicalType.getLogicalName());
        }

        return schemaBuilder.build();
    }

    private Schema getArraySchema(ArrayDataType type) {
        DataType valueType = type.getElementDataType();
        Schema valueSchema = getFieldSchema(valueType);
        SchemaBuilder schemaBuilder = SchemaBuilder.array(valueSchema);
        if (type.isNullable()) {
            schemaBuilder.optional().defaultValue(null);
        }
        return schemaBuilder.build();
    }

    private Schema getObjectSchema(ClassDataType type) {
        SchemaBuilder schemaBuilder = SchemaBuilder.struct();
        schemaBuilder.name(type.getFixedDescriptor().getName());

        for (DataField field : type.getFixedDescriptor().getFields()) {
            Schema valueSchema = getFieldSchema(field.getType());
            schemaBuilder.field(field.getName(), valueSchema);
            LOG.info("Adding field " + field.getName() + " -- " + valueSchema.type() + " IS OPTIONAL: " + valueSchema.isOptional());
        }

        if (type.isNullable()) {
            schemaBuilder.optional().defaultValue(null);
        }
        return schemaBuilder.build();
    }
}
